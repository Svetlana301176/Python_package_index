# Домашнее задание по теме "Обзор сторонних библиотек Python"
# Задание: Обзор сторонних библиотек Python
#
# Цель:
# Познакомиться с использованием сторонних библиотек в Python и применить их в различных задачах.
#
# Инструкции:
# 1. Выберите одну или несколько сторонних библиотек Python, например, requests, pandas, numpy, matplotlib, pillow и другие.
# 2. Изучите документацию выбранных библиотек, ознакомьтесь с их основными возможностями и функциями.
# 3. Напишите простые задачи, в которых нужно использовать выбранные библиотеки, и выполните их. Приведите примеры использования библиотек в различных сценариях:
#   - Запросить данные с помощью библиотеки requests из API и вывести их в консоль.
#   - Считать данные из файла с помощью библиотеки pandas, выполнить простой анализ данных и вывести результаты.
#   - Создать массив чисел с помощью библиотеки numpy, выполнить математические операции с массивом и вывести результаты.
#   - Визуализировать данные с помощью библиотеки matplotlib.
#   - Обработать изображение с помощью библиотеки pillow, например, изменить его размер, применить эффекты и сохранить в другой формат.
# 4. Поясните, как выбранные библиотеки помогли в решении поставленных задач и какие преимущества они предоставили по сравнению с базовым функционалом Python.
#
# Рекомендации:
# - Используйте документацию и примеры кода из официальных ресурсов выбранных библиотек.
# - Экспериментируйте с разными параметрами и функциями в выбранных библиотеках, чтобы лучше понять их возможности.
# - Делайте выводы о преимуществах и удобстве использования сторонних библиотек в различных задачах.
#
# Оценка:
# Оценивайте выполнение задания по следующим критериям:
# - Верное использование выбранных сторонних библиотек Python.
# - Корректная работа и отображение результатов в соответствии с задачами.
# - Качество и полнота выполнения задания.


# Для выполнения данной задачи, выбираем следующие сторонние библиотеки Python:
#
#
#
# requests: Для выполнения HTTP-запросов к API.
#
# pandas: Для работы с данными в формате таблиц (DataFrame).
#
# numpy: Для выполнения математических операций с массивами.
#
# matplotlib: Для визуализации данных.
#
# Pillow: Для обработки изображений.
#
#
# выполним задачи по каждой библиотеке:


# Задача 1: Использование библиотеки requests

# import requests
# # Функция для запроса и вывода данных с API
# def get_api_data_raw(url): # определяем функцию get_api_data_raw, которая принимает URL в качестве аргумента.
#     try:
#         response = requests.get(url) # выполняем GET-запрос к указанному URL с помощью requests.get(url).
#         response.raise_for_status()  # Проверка на ошибки запроса
#
#         data = response.text  # Получение текстового содержимого ответа
#
#         # Вывод текстового содержимого ответа
#         print("Текстовое содержимое ответа:")
#         print(data)
#     except requests.exceptions.RequestException as e: # использовали конструкцию try-except для обработки исключений
#         # типа requests.exceptions.RequestException, которые могут возникнуть при выполнении запроса.
#         print("Ошибка при выполнении запроса:", e)
#
# # URL API для запроса данных
# api_url = 'https://stepik.org/'
#
#
#
# # Вызов функции для получения и вывода данных с API
# get_api_data_raw(api_url)
# Этот код позволяет отправить GET-запрос к указанному URL, получить текстовое содержимое ответа и вывести его в консоль.


# Задача 2: Использование библиотеки pandas (pandas: Для работы с данными в формате таблиц (DataFrame).

# import pandas as pd
#
# city = {'Город': ['Братск', 'Санкт-Петербург', 'Новосибирск', 'Екатеринбург'],
#         'Год основания': [1955, 1703, 1893, 1723],
#         'Население': [0.2, 4.9, 1.5, 1.4]} # Создаём словарь с нужной информацией о городах.
#
# df = pd.DataFrame(city) # Превращаем словарь в DataFrame, используя стандартный метод библиотеки.
#
# print (df) # Выводим DataFrame на экран.
#
# print(df.dtypes) # Проверяем тип данных в таблице
#
# # простой пример
# series_example = pd.Series([4, 8, -10, 6]) # Создаём объект Series, содержащий числа.
#
# print(series_example) # Выводим объект на экран.
#
# # Еще Создание примера данных
# data = {
#     'имя': ['Alice', 'Bob', 'Charlie', 'David'],
#     'возраст': [25, 30, 35, 40],
#     'value': [100, 200, 150, 300]
# }
#
# # Создание DataFrame из примера данных
# df = pd.DataFrame(data)
# print (df) # Выводим DataFrame на экран.
#
# # Простой анализ данных
# if not df.empty:
#     # Вычисление среднего значения столбца 'value'
#     mean_value = df['value'].mean()
#     print("Среднее значение столбца 'value':", mean_value)
#
#     # Нахождение максимального значения столбца 'value'
#     max_value = df['value'].max()
#     print("Максимальное значение столбца 'value':", max_value)
# else:
#     print("Данные не найдены.")

# Задача 3: Использование библиотеки numpy

# import numpy as np
#
# # Создаем массив чисел с помощью numpy
# arr = np.array([1, 2, 3, 4, 5])
#
# # Математические операции с массивом
# arr_squared = np.square(arr)
# arr_sum = np.sum(arr)
#
# # Вывод результатов
# print("Массив в квадрате:", arr_squared)
# print("Сумма элементов массива:", arr_sum)
#
# arr2 = np.array([[1, 2, 3], [4, 5, 6]])
# arr3 = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
#
# arr_squared2 = np.square(arr2)
# arr_sum2 = np.sum(arr2)
#
# print("Массив2 в квадрате:", arr_squared2)
# print("Сумма элементов массива2:", arr_sum2)
#
# arr_squared3 = np.square(arr3)
# arr_sum3 = np.sum(arr3)
#
# print("Массив3 в квадрате:", arr_squared3)
# print("Сумма элементов массива3:", arr_sum3)
# #  чтобы узнать сколько у массива измерений, воспользуемся функцией ndim
# print(arr.ndim)
# print(arr2.ndim)
# print(arr3.ndim)
# # чтобы узнать сколько у массива количество строк и столбцов? Для этого есть функция shape:
# print(arr.shape)
# print(arr2.shape)
# print(arr3.shape)
#
# # узнать тип элементов — в этом поможет функция dtype (не путайте её с одноимённым параметром):
# print(arr.dtype)
# print(arr2.dtype)
# print(arr3.dtype)
#
# # узнать количество элементов с помощью функции size:
# print(arr.size)
# print(arr2.size)
# print(arr3.size)
#
# # через функции itemsize и nbytes можно узнать, какое количество байт в памяти занимает один элемент и
# # какое количество байт занимает весь массив:
# print(arr.itemsize)
# print(arr.nbytes)
# print(arr2.itemsize)
# print(arr2.nbytes)
# print(arr3.itemsize)
# print(arr3.nbytes)
#
# # Массив из нулей. Чтобы создать его, используем функцию zeros.
# a = np.zeros((2, 2))
# print(a)
#
# # Массив из единиц. Он создаётся точно так же, как и из нулей, но используется функция ones:
# b = np.ones((4, 2, 2))
# print(b)
#
# # Массив из произвольных чисел. Иногда бывает нужно заполнить массив какими-то отличными от нуля и единицы числами.
# # В этом поможет функция full:
# c = np.full((2, 2), 5)
# print(c)
#
# # Массив случайных чисел. Он создаётся с помощью функции random.rand:
# # NumPy генерирует случайные числа в диапазоне от 0 до 1 с восемью знаками после запятой.
# d = np.random.rand(3, 2)
# print(d)
#
# # создадим массив размером четыре на четыре — size=(4, 4) — с целыми числами из диапазона от –5 до 10.
# e = np.random.randint(-5, 10, size=(4, 4))
#
# print(e)
#
# # Математические операции
# # Массивы из NumPy поддерживают все стандартные арифметические операции — например, сложение, деление, вычитание.
# # Работает это поэлементно:
#
# a = np.array([1, 2, 3, 4])
# print(a)
# print(a + 3)
# print(a - 2)
# print(a * 2)
# print(a / 2)
# print(a ** 2)
#
# # Ещё можно проводить любые математические операции с массивами одинакового размера:
# a = np.array([[1, 2], [3, 4]])
# b = np.array([[2, 2], [2, 2]])
# print(a + b)
# print(a * b)
# print(a // b)
#
# # Задача 4: Использование библиотеки matplotlib
#
#
# import matplotlib.pyplot as plt
#
# # Создаем данные для визуализации
# x = range(0, 10)
# y = [i**2 for i in x]
#
# # Строим график 1
# plt.plot(x, y)
# plt.xlabel('X')
# plt.ylabel('Y')
# plt.title('График Y=X^2')
# plt.show()
#
# # Строим график 2
# x = [1, 2, 3, 4, 5]
# y = [25, 32, 34, 20, 25]
# # Теперь построим график, который соединит эти точки:
# plt.title('График')
# plt.plot(x, y)
# plt.show()
# # Мы получили обычный линейный график. Разберём каждую команду:
# # plt.plot() — стандартная функция, которая строит график в соответствии со значениями, которые ей были переданы. Мы передали в неё координаты точек;
# # plt.show() — функция, которая отвечает за вывод визуализированных данных на экран. Её можно и не указывать, но тогда, помимо красивой картинки, мы увидим разную техническую информацию.
#
# # столбчатая диаграмма позволяет наглядно показать величину прибыли по месяцам. Построим следующий график:
#
# x = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май']
# y = [2, 4, 3, 1, 7]
#
# plt.bar(x, y, label='Величина прибыли') #Параметр label позволяет задать название величины для легенды
# plt.xlabel('Месяц года')
# plt.ylabel('Прибыль, в млн руб.')
# plt.title('Пример столбчатой диаграммы')
# plt.legend()
# plt.show()
#
# # Круговую диаграмму используют для отображения состава групп. Например, мы можем наглядно показать, какие марки автомобилей преобладают на дорогах города:
# vals = [24, 17, 53, 21, 35]
# labels = ["Ford", "Toyota", "BMW", "Audi", "Jaguar"]
# plt.pie(vals, labels=labels, autopct='%1.1f%%')
# plt.title("Распределение марок автомобилей на дороге")
# plt.show()

# Задача 5: Использование библиотеки Pillow

from PIL import Image

# Открываем изображение
img = Image.open('image.jpg')

# Изменяем размер изображения
resized_img = img.resize((300, 300))

# Сохраняем обработанное изображение
resized_img.save('resized_image.jpg')

print("Изображение обработано и сохранено.")

# Эти примеры демонстрируют разнообразные сценарии использования выбранных библиотек.
# Библиотеки позволяют эффективно работать с данными, выполнять сложные операции и
# создавать визуальные представления, что значительно упрощает и ускоряет процесс разработки
# по сравнению с использованием базового функционала Python.
